//! # Entities Module
//!
//! Entity-component system for managing game objects like players, monsters, and items.
//!
//! This module implements a flexible entity system that can be extended by the LLDM
//! for creating unique creatures, items, and interactive objects. All entities are
//! serializable for save/load functionality and MCP integration.

use crate::{config, new_entity_id, EntityId, Position, ThatchError, ThatchResult};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Core trait that all game entities must implement.
///
/// This trait defines the common interface for all entities in the game,
/// whether they are controlled by the player, AI, or generated by the LLDM.
pub trait Entity {
    /// Gets the unique identifier for this entity.
    fn id(&self) -> EntityId;

    /// Gets the current position of this entity.
    fn position(&self) -> Position;

    /// Sets the position of this entity.
    fn set_position(&mut self, position: Position);

    /// Gets the display character for this entity.
    fn display_char(&self) -> char;

    /// Gets the name/description of this entity.
    fn name(&self) -> &str;

    /// Gets the entity type for serialization and identification.
    fn entity_type(&self) -> EntityType;

    /// Checks if this entity is alive/active.
    fn is_alive(&self) -> bool;

    /// Updates the entity (for AI, effects, etc.).
    fn update(&mut self) -> ThatchResult<Vec<GameEvent>>;

    /// Handles incoming events that affect this entity.
    fn handle_event(&mut self, event: &GameEvent) -> ThatchResult<Vec<GameEvent>>;

    /// Serializes the entity to JSON for save/load and MCP.
    fn to_json(&self) -> ThatchResult<String>;

    /// Gets metadata for LLDM integration.
    fn metadata(&self) -> &HashMap<String, String>;

    /// Sets metadata for LLDM integration.
    fn set_metadata(&mut self, key: String, value: String);
}

/// Enumeration of different entity types in the game.
///
/// This is used for serialization, deserialization, and type identification.
/// The LLDM can create entities with the `LldmGenerated` type for custom content.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum EntityType {
    /// Player character
    Player,
    /// Basic monster types
    Monster(MonsterType),
    /// Item types
    Item(ItemType),
    /// Non-player characters
    Npc,
    /// LLDM-generated entity with custom behavior
    LldmGenerated { subtype: String },
}

/// Different types of monsters in the game.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum MonsterType {
    /// Weak, common enemy
    Goblin,
    /// Stronger melee fighter
    Orc,
    /// Magical enemy
    Wizard,
    /// Undead creature
    Skeleton,
    /// Large, powerful enemy
    Troll,
    /// Boss-level creature
    Dragon,
    /// LLDM can create custom monster types
    Custom(String),
}

/// Different types of items in the game.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ItemType {
    /// Weapons for combat
    Weapon(WeaponType),
    /// Armor for protection
    Armor(ArmorType),
    /// Consumable items
    Consumable(ConsumableType),
    /// Quest or story items
    QuestItem,
    /// Treasure and valuables
    Treasure,
    /// LLDM can create custom item types
    Custom(String),
}

/// Weapon subtypes.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum WeaponType {
    Sword,
    Dagger,
    Bow,
    Staff,
    Mace,
    Custom(String),
}

/// Armor subtypes.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ArmorType {
    Helmet,
    ChestArmor,
    Boots,
    Shield,
    Ring,
    Custom(String),
}

/// Consumable item subtypes.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ConsumableType {
    HealthPotion,
    ManaPotion,
    Food,
    Scroll,
    Custom(String),
}

/// Events that can occur in the game world.
///
/// These events are used for communication between entities and systems,
/// and can be serialized for MCP integration and logging.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum GameEvent {
    /// An entity moved to a new position
    EntityMoved {
        entity_id: EntityId,
        from: Position,
        to: Position,
    },
    /// An entity took damage
    EntityDamaged {
        entity_id: EntityId,
        damage: u32,
        source: Option<EntityId>,
    },
    /// An entity was healed
    EntityHealed {
        entity_id: EntityId,
        amount: u32,
        source: Option<EntityId>,
    },
    /// An entity died
    EntityDied {
        entity_id: EntityId,
        killer: Option<EntityId>,
    },
    /// An entity was created
    EntityCreated {
        entity_id: EntityId,
        entity_type: EntityType,
        position: Position,
    },
    /// An item was picked up
    ItemPickedUp {
        item_id: EntityId,
        picker_id: EntityId,
    },
    /// An item was dropped
    ItemDropped {
        item_id: EntityId,
        dropper_id: EntityId,
        position: Position,
    },
    /// A message should be displayed to the player
    Message {
        text: String,
        importance: MessageImportance,
    },
    /// LLDM-generated event with custom data
    LldmEvent {
        event_type: String,
        data: HashMap<String, String>,
    },
}

/// Importance levels for game messages.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum MessageImportance {
    /// Low priority, can be ignored
    Info,
    /// Normal game information
    Normal,
    /// Important information the player should see
    Important,
    /// Critical information (damage, death, etc.)
    Critical,
}

/// Basic stats that most entities have.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EntityStats {
    /// Current health points
    pub health: u32,
    /// Maximum health points
    pub max_health: u32,
    /// Current mana/magic points
    pub mana: u32,
    /// Maximum mana points
    pub max_mana: u32,
    /// Physical attack power
    pub attack: u32,
    /// Physical defense
    pub defense: u32,
    /// Movement speed (higher = faster)
    pub speed: u32,
    /// Experience points (for player)
    pub experience: u32,
    /// Character level
    pub level: u32,
}

impl EntityStats {
    /// Creates new stats with default values.
    pub fn new() -> Self {
        Self {
            health: config::DEFAULT_PLAYER_HEALTH,
            max_health: config::DEFAULT_PLAYER_HEALTH,
            mana: 50,
            max_mana: 50,
            attack: 10,
            defense: 5,
            speed: 100,
            experience: 0,
            level: 1,
        }
    }

    /// Creates stats for a specific monster type.
    pub fn for_monster(monster_type: &MonsterType) -> Self {
        match monster_type {
            MonsterType::Goblin => Self {
                health: 20,
                max_health: 20,
                mana: 0,
                max_mana: 0,
                attack: 5,
                defense: 2,
                speed: 110,
                experience: 0,
                level: 1,
            },
            MonsterType::Orc => Self {
                health: 40,
                max_health: 40,
                mana: 0,
                max_mana: 0,
                attack: 12,
                defense: 8,
                speed: 80,
                experience: 0,
                level: 2,
            },
            MonsterType::Dragon => Self {
                health: 500,
                max_health: 500,
                mana: 200,
                max_mana: 200,
                attack: 50,
                defense: 30,
                speed: 60,
                experience: 0,
                level: 20,
            },
            _ => Self::new(), // Default for other types
        }
    }

    /// Checks if the entity is alive.
    pub fn is_alive(&self) -> bool {
        self.health > 0
    }

    /// Applies damage, returns actual damage dealt.
    pub fn take_damage(&mut self, damage: u32) -> u32 {
        let actual_damage = damage.saturating_sub(self.defense / 2);
        self.health = self.health.saturating_sub(actual_damage);
        actual_damage
    }

    /// Heals the entity, returns actual healing done.
    pub fn heal(&mut self, amount: u32) -> u32 {
        let old_health = self.health;
        self.health = (self.health + amount).min(self.max_health);
        self.health - old_health
    }

    /// Restores mana, returns actual mana restored.
    pub fn restore_mana(&mut self, amount: u32) -> u32 {
        let old_mana = self.mana;
        self.mana = (self.mana + amount).min(self.max_mana);
        self.mana - old_mana
    }
}

impl Default for EntityStats {
    fn default() -> Self {
        Self::new()
    }
}

/// The player character entity.
///
/// Represents the player-controlled character with full stats,
/// inventory, and special abilities.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlayerCharacter {
    /// Unique entity ID
    pub id: EntityId,
    /// Current position in the world
    pub position: Position,
    /// Character name
    pub name: String,
    /// Character stats
    pub stats: EntityStats,
    /// Equipment slots
    pub equipment: HashMap<String, EntityId>,
    /// Inventory items
    pub inventory: Vec<EntityId>,
    /// Maximum inventory size
    pub inventory_capacity: usize,
    /// Field of view radius
    pub sight_radius: u32,
    /// LLDM integration metadata
    pub metadata: HashMap<String, String>,
}

impl PlayerCharacter {
    /// Creates a new player character.
    ///
    /// # Examples
    ///
    /// ```
    /// use thatch::{PlayerCharacter, Position, Entity};
    ///
    /// let player = PlayerCharacter::new("Hero".to_string(), Position::new(10, 10));
    /// assert_eq!(player.name, "Hero");
    /// assert_eq!(player.position, Position::new(10, 10));
    /// assert!(player.is_alive());
    /// ```
    pub fn new(name: String, position: Position) -> Self {
        Self {
            id: new_entity_id(),
            position,
            name,
            stats: EntityStats::new(),
            equipment: HashMap::new(),
            inventory: Vec::new(),
            inventory_capacity: 20,
            sight_radius: 8,
            metadata: HashMap::new(),
        }
    }

    /// Checks if the player can pick up an item (inventory not full).
    pub fn can_pick_up_item(&self) -> bool {
        self.inventory.len() < self.inventory_capacity
    }

    /// Adds an item to the player's inventory.
    pub fn add_to_inventory(&mut self, item_id: EntityId) -> ThatchResult<()> {
        if !self.can_pick_up_item() {
            return Err(ThatchError::InvalidAction("Inventory is full".to_string()));
        }
        self.inventory.push(item_id);
        Ok(())
    }

    /// Removes an item from the player's inventory.
    pub fn remove_from_inventory(&mut self, item_id: &EntityId) -> bool {
        if let Some(pos) = self.inventory.iter().position(|id| id == item_id) {
            self.inventory.remove(pos);
            true
        } else {
            false
        }
    }

    /// Equips an item in the specified slot.
    pub fn equip_item(&mut self, slot: String, item_id: EntityId) -> Option<EntityId> {
        self.equipment.insert(slot, item_id)
    }

    /// Unequips an item from the specified slot.
    pub fn unequip_item(&mut self, slot: &str) -> Option<EntityId> {
        self.equipment.remove(slot)
    }

    /// Gets the item equipped in the specified slot.
    pub fn get_equipped_item(&self, slot: &str) -> Option<&EntityId> {
        self.equipment.get(slot)
    }
}

impl Entity for PlayerCharacter {
    fn id(&self) -> EntityId {
        self.id
    }

    fn position(&self) -> Position {
        self.position
    }

    fn set_position(&mut self, position: Position) {
        self.position = position;
    }

    fn display_char(&self) -> char {
        '@'
    }

    fn name(&self) -> &str {
        &self.name
    }

    fn entity_type(&self) -> EntityType {
        EntityType::Player
    }

    fn is_alive(&self) -> bool {
        self.stats.is_alive()
    }

    fn update(&mut self) -> ThatchResult<Vec<GameEvent>> {
        // Player doesn't have autonomous updates
        Ok(Vec::new())
    }

    fn handle_event(&mut self, event: &GameEvent) -> ThatchResult<Vec<GameEvent>> {
        match event {
            GameEvent::EntityDamaged {
                entity_id,
                damage,
                source,
            } if *entity_id == self.id => {
                let actual_damage = self.stats.take_damage(*damage);
                let mut events = vec![];

                if !self.is_alive() {
                    events.push(GameEvent::EntityDied {
                        entity_id: self.id,
                        killer: *source,
                    });
                    events.push(GameEvent::Message {
                        text: "You have died!".to_string(),
                        importance: MessageImportance::Critical,
                    });
                } else if actual_damage > 0 {
                    events.push(GameEvent::Message {
                        text: format!("You take {} damage!", actual_damage),
                        importance: MessageImportance::Important,
                    });
                }

                Ok(events)
            }
            GameEvent::EntityHealed {
                entity_id, amount, ..
            } if *entity_id == self.id => {
                let actual_healing = self.stats.heal(*amount);
                if actual_healing > 0 {
                    Ok(vec![GameEvent::Message {
                        text: format!("You are healed for {} health!", actual_healing),
                        importance: MessageImportance::Normal,
                    }])
                } else {
                    Ok(vec![])
                }
            }
            _ => Ok(vec![]),
        }
    }

    fn to_json(&self) -> ThatchResult<String> {
        serde_json::to_string(self).map_err(ThatchError::from)
    }

    fn metadata(&self) -> &HashMap<String, String> {
        &self.metadata
    }

    fn set_metadata(&mut self, key: String, value: String) {
        self.metadata.insert(key, value);
    }
}

/// Container for managing all entities in the game.
///
/// Provides efficient access to entities by ID and type, and handles
/// entity lifecycle management.
///
/// NOTE: Temporarily commented out due to trait object serialization issues.
/// The GameState uses ConcreteEntity enum instead.
/*
#[derive(Clone, Serialize, Deserialize)]
pub struct EntityManager {
    /// All entities indexed by their ID
    entities: HashMap<EntityId, Box<dyn Entity>>,
    /// Player entity ID for quick access
    player_id: Option<EntityId>,
    /// Entities by position for spatial queries
    position_index: HashMap<Position, Vec<EntityId>>,
}
*/
// Note: Due to Rust's object safety limitations, we'll need to implement
// a custom serialization strategy for trait objects. For now, we'll use
// an enum-based approach for concrete entity types.

/// Concrete entity types for serialization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ConcreteEntity {
    Player(PlayerCharacter),
    // Additional concrete types will be added as we implement them
}

impl ConcreteEntity {
    /// Gets the entity ID.
    pub fn id(&self) -> EntityId {
        match self {
            ConcreteEntity::Player(player) => player.id(),
        }
    }

    /// Gets the entity position.
    pub fn position(&self) -> Position {
        match self {
            ConcreteEntity::Player(player) => player.position(),
        }
    }

    /// Checks if the entity is alive.
    pub fn is_alive(&self) -> bool {
        match self {
            ConcreteEntity::Player(player) => player.is_alive(),
        }
    }
}

impl From<PlayerCharacter> for ConcreteEntity {
    fn from(player: PlayerCharacter) -> Self {
        ConcreteEntity::Player(player)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_entity_stats_creation() {
        let stats = EntityStats::new();
        assert_eq!(stats.health, config::DEFAULT_PLAYER_HEALTH);
        assert_eq!(stats.max_health, config::DEFAULT_PLAYER_HEALTH);
        assert!(stats.is_alive());
    }

    #[test]
    fn test_entity_stats_damage() {
        let mut stats = EntityStats::new();
        let damage_dealt = stats.take_damage(20);

        assert_eq!(damage_dealt, 20 - stats.defense / 2);
        assert_eq!(stats.health, config::DEFAULT_PLAYER_HEALTH - damage_dealt);
        assert!(stats.is_alive());
    }

    #[test]
    fn test_entity_stats_death() {
        let mut stats = EntityStats::new();
        let fatal_damage = stats.max_health + 100;
        stats.take_damage(fatal_damage);

        assert!(!stats.is_alive());
        assert_eq!(stats.health, 0);
    }

    #[test]
    fn test_entity_stats_healing() {
        let mut stats = EntityStats::new();
        stats.take_damage(50);

        let old_health = stats.health;
        let healing = stats.heal(30);

        assert_eq!(stats.health, old_health + healing);
        assert!(stats.health <= stats.max_health);
    }

    #[test]
    fn test_player_character_creation() {
        let name = "TestHero".to_string();
        let pos = Position::new(5, 10);
        let player = PlayerCharacter::new(name.clone(), pos);

        assert_eq!(player.name, name);
        assert_eq!(player.position, pos);
        assert_eq!(player.display_char(), '@');
        assert!(player.is_alive());
    }

    #[test]
    fn test_player_inventory_management() {
        let mut player = PlayerCharacter::new("Test".to_string(), Position::origin());
        let item_id = new_entity_id();

        assert!(player.can_pick_up_item());
        assert!(player.add_to_inventory(item_id).is_ok());
        assert!(player.inventory.contains(&item_id));

        assert!(player.remove_from_inventory(&item_id));
        assert!(!player.inventory.contains(&item_id));
    }

    #[test]
    fn test_player_equipment() {
        let mut player = PlayerCharacter::new("Test".to_string(), Position::origin());
        let sword_id = new_entity_id();

        let old_weapon = player.equip_item("weapon".to_string(), sword_id);
        assert!(old_weapon.is_none());
        assert_eq!(player.get_equipped_item("weapon"), Some(&sword_id));

        let unequipped = player.unequip_item("weapon");
        assert_eq!(unequipped, Some(sword_id));
        assert_eq!(player.get_equipped_item("weapon"), None);
    }

    #[test]
    fn test_player_damage_event_handling() {
        let mut player = PlayerCharacter::new("Test".to_string(), Position::origin());
        let attacker_id = new_entity_id();

        let damage_event = GameEvent::EntityDamaged {
            entity_id: player.id(),
            damage: 30,
            source: Some(attacker_id),
        };

        let events = player.handle_event(&damage_event).unwrap();
        assert!(!events.is_empty());

        // Check if a message event was generated
        let has_message = events
            .iter()
            .any(|e| matches!(e, GameEvent::Message { .. }));
        assert!(has_message);
    }

    #[test]
    fn test_monster_stats_creation() {
        let goblin_stats = EntityStats::for_monster(&MonsterType::Goblin);
        assert_eq!(goblin_stats.health, 20);
        assert_eq!(goblin_stats.attack, 5);

        let dragon_stats = EntityStats::for_monster(&MonsterType::Dragon);
        assert_eq!(dragon_stats.health, 500);
        assert_eq!(dragon_stats.level, 20);
    }

    #[test]
    fn test_entity_serialization() {
        let player = PlayerCharacter::new("Test".to_string(), Position::new(1, 2));
        let json = player.to_json().unwrap();

        // Should be valid JSON
        let _: serde_json::Value = serde_json::from_str(&json).unwrap();
    }
}
