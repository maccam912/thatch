//! # World Module
//!
//! Contains the world representation, levels, and tile systems.
//!
//! The world is composed of multiple levels, each containing a grid of tiles
//! and collections of entities. This module provides the core data structures
//! and operations for managing the game world.

use crate::{config, EntityId, Position, ThatchError, ThatchResult};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Represents different types of tiles in the game world.
///
/// Each tile type has different properties for movement, visibility,
/// and interaction. This enum is designed to be extensible for future
/// tile types that might be generated by the LLDM system.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum TileType {
    /// Empty floor space that can be walked on
    Floor,
    /// Solid wall that blocks movement and sight
    Wall,
    /// Door that can be opened/closed (future: LLDM can create special doors)
    Door { is_open: bool },
    /// Stairs leading to another level
    StairsUp,
    /// Stairs leading down to another level
    StairsDown,
    /// Water that might slow movement or require swimming
    Water,
    /// Special tile type for LLDM-generated content
    Special { description: String },
}

impl TileType {
    /// Returns true if entities can move through this tile.
    ///
    /// # Examples
    ///
    /// ```
    /// use thatch::TileType;
    ///
    /// assert!(TileType::Floor.is_passable());
    /// assert!(!TileType::Wall.is_passable());
    /// assert!(TileType::Door { is_open: true }.is_passable());
    /// assert!(!TileType::Door { is_open: false }.is_passable());
    /// ```
    pub fn is_passable(&self) -> bool {
        match self {
            TileType::Floor | TileType::StairsUp | TileType::StairsDown | TileType::Water => true,
            TileType::Wall => false,
            TileType::Door { is_open } => *is_open,
            TileType::Special { .. } => true, // Default to passable for LLDM content
        }
    }

    /// Returns true if sight can pass through this tile.
    pub fn is_transparent(&self) -> bool {
        match self {
            TileType::Floor | TileType::StairsUp | TileType::StairsDown | TileType::Water => true,
            TileType::Wall => false,
            TileType::Door { is_open } => *is_open,
            TileType::Special { .. } => true, // Default to transparent for LLDM content
        }
    }

    /// Returns the character representation for rendering.
    pub fn to_char(self) -> char {
        match self {
            TileType::Floor => '.',
            TileType::Wall => '#',
            TileType::Door { is_open: true } => '/',
            TileType::Door { is_open: false } => '+',
            TileType::StairsUp => '<',
            TileType::StairsDown => '>',
            TileType::Water => '~',
            TileType::Special { .. } => '?', // LLDM can override this
        }
    }
}

/// Represents a single tile in the game world.
///
/// Contains the tile type and any additional metadata needed for
/// gameplay mechanics or LLDM integration.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Tile {
    /// The type of this tile
    pub tile_type: TileType,
    /// Whether this tile has been explored by the player
    pub explored: bool,
    /// Whether this tile is currently visible to the player
    pub visible: bool,
    /// Optional metadata for LLDM-generated content
    pub metadata: Option<HashMap<String, String>>,
}

impl Tile {
    /// Creates a new tile of the specified type.
    ///
    /// # Examples
    ///
    /// ```
    /// use thatch::{Tile, TileType};
    ///
    /// let floor_tile = Tile::new(TileType::Floor);
    /// assert!(!floor_tile.explored);
    /// assert!(!floor_tile.visible);
    /// ```
    pub fn new(tile_type: TileType) -> Self {
        Self {
            tile_type,
            explored: false,
            visible: false,
            metadata: None,
        }
    }

    /// Creates a new floor tile (common case).
    pub fn floor() -> Self {
        Self::new(TileType::Floor)
    }

    /// Creates a new wall tile (common case).
    pub fn wall() -> Self {
        Self::new(TileType::Wall)
    }

    /// Marks this tile as explored by the player.
    pub fn mark_explored(&mut self) {
        self.explored = true;
    }

    /// Sets the visibility of this tile.
    pub fn set_visible(&mut self, visible: bool) {
        self.visible = visible;
        if visible {
            self.explored = true;
        }
    }

    /// Adds metadata to this tile (useful for LLDM integration).
    pub fn add_metadata(&mut self, key: String, value: String) {
        if self.metadata.is_none() {
            self.metadata = Some(HashMap::new());
        }
        self.metadata.as_mut().unwrap().insert(key, value);
    }

    /// Gets metadata value by key.
    pub fn get_metadata(&self, key: &str) -> Option<&String> {
        self.metadata.as_ref()?.get(key)
    }

    /// Returns true if this tile is currently visible to the player.
    pub fn is_visible(&self) -> bool {
        self.visible
    }

    /// Returns true if this tile has been explored by the player.
    pub fn is_explored(&self) -> bool {
        self.explored
    }
}

/// Represents a single level/floor in the dungeon.
///
/// Each level contains a 2D grid of tiles and tracks entities present
/// on that level. Levels are generated procedurally and can be enhanced
/// by the LLDM system.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Level {
    /// Unique identifier for this level
    pub id: u32,
    /// Width of the level in tiles
    pub width: u32,
    /// Height of the level in tiles
    pub height: u32,
    /// 2D grid of tiles (row-major order)
    pub tiles: Vec<Vec<Tile>>,
    /// Entities currently on this level
    pub entities: Vec<EntityId>,
    /// Spawn point for the player on this level
    pub player_spawn: Position,
    /// Optional name/description for this level (LLDM can set this)
    pub name: Option<String>,
    /// Level-specific metadata for LLDM integration
    pub metadata: HashMap<String, String>,
}

impl Level {
    /// Creates a new level with the specified dimensions.
    ///
    /// All tiles are initialized as walls. Use generation algorithms
    /// to create the actual level layout.
    ///
    /// # Examples
    ///
    /// ```
    /// use thatch::Level;
    ///
    /// let level = Level::new(0, 80, 40);
    /// assert_eq!(level.width, 80);
    /// assert_eq!(level.height, 40);
    /// assert_eq!(level.tiles.len(), 40); // rows
    /// assert_eq!(level.tiles[0].len(), 80); // columns
    /// ```
    pub fn new(id: u32, width: u32, height: u32) -> Self {
        let tiles = (0..height)
            .map(|_| (0..width).map(|_| Tile::wall()).collect())
            .collect();

        Self {
            id,
            width,
            height,
            tiles,
            entities: Vec::new(),
            player_spawn: Position::new(width as i32 / 2, height as i32 / 2),
            name: None,
            metadata: HashMap::new(),
        }
    }

    /// Checks if the given position is within the level bounds.
    ///
    /// # Examples
    ///
    /// ```
    /// use thatch::{Level, Position};
    ///
    /// let level = Level::new(0, 10, 10);
    /// assert!(level.is_valid_position(Position::new(5, 5)));
    /// assert!(!level.is_valid_position(Position::new(15, 5)));
    /// assert!(!level.is_valid_position(Position::new(-1, 5)));
    /// ```
    pub fn is_valid_position(&self, pos: Position) -> bool {
        pos.x >= 0 && pos.y >= 0 && pos.x < self.width as i32 && pos.y < self.height as i32
    }

    /// Gets a reference to the tile at the specified position.
    ///
    /// Returns `None` if the position is out of bounds.
    pub fn get_tile(&self, pos: Position) -> Option<&Tile> {
        if !self.is_valid_position(pos) {
            return None;
        }
        Some(&self.tiles[pos.y as usize][pos.x as usize])
    }

    /// Gets a mutable reference to the tile at the specified position.
    ///
    /// Returns `None` if the position is out of bounds.
    pub fn get_tile_mut(&mut self, pos: Position) -> Option<&mut Tile> {
        if !self.is_valid_position(pos) {
            return None;
        }
        Some(&mut self.tiles[pos.y as usize][pos.x as usize])
    }

    /// Sets the tile at the specified position.
    ///
    /// Returns an error if the position is out of bounds.
    pub fn set_tile(&mut self, pos: Position, tile: Tile) -> ThatchResult<()> {
        if !self.is_valid_position(pos) {
            return Err(ThatchError::InvalidState(format!(
                "Position {:?} is out of bounds for level {}x{}",
                pos, self.width, self.height
            )));
        }
        self.tiles[pos.y as usize][pos.x as usize] = tile;
        Ok(())
    }

    /// Checks if the given position is passable (can be moved through).
    pub fn is_passable(&self, pos: Position) -> bool {
        self.get_tile(pos)
            .map(|tile| tile.tile_type.is_passable())
            .unwrap_or(false)
    }

    /// Checks if the given position is transparent (sight can pass through).
    pub fn is_transparent(&self, pos: Position) -> bool {
        self.get_tile(pos)
            .map(|tile| tile.tile_type.is_transparent())
            .unwrap_or(false)
    }

    /// Adds an entity to this level.
    pub fn add_entity(&mut self, entity_id: EntityId) {
        if !self.entities.contains(&entity_id) {
            self.entities.push(entity_id);
        }
    }

    /// Removes an entity from this level.
    pub fn remove_entity(&mut self, entity_id: &EntityId) {
        self.entities.retain(|id| id != entity_id);
    }

    /// Gets all entities on this level.
    pub fn get_entities(&self) -> &[EntityId] {
        &self.entities
    }

    /// Sets metadata for this level (useful for LLDM integration).
    pub fn set_metadata(&mut self, key: String, value: String) {
        self.metadata.insert(key, value);
    }

    /// Gets metadata value by key.
    pub fn get_metadata(&self, key: &str) -> Option<&String> {
        self.metadata.get(key)
    }
}

/// The complete game world containing multiple levels.
///
/// Manages the collection of levels and provides methods for
/// level transitions and world-wide operations.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct World {
    /// All levels in the world, indexed by level ID
    pub levels: HashMap<u32, Level>,
    /// The currently active level
    pub current_level_id: u32,
    /// Maximum depth reached by the player
    pub max_depth: u32,
    /// World seed for consistent generation
    pub seed: u64,
    /// World-wide metadata for LLDM integration
    pub metadata: HashMap<String, String>,
}

impl World {
    /// Creates a new world with an initial level.
    ///
    /// # Examples
    ///
    /// ```
    /// use thatch::World;
    ///
    /// let world = World::new(12345);
    /// assert_eq!(world.current_level_id, 0);
    /// assert_eq!(world.max_depth, 0);
    /// assert!(world.levels.contains_key(&0));
    /// ```
    pub fn new(seed: u64) -> Self {
        let mut levels = HashMap::new();
        let initial_level = Level::new(
            0,
            config::DEFAULT_DUNGEON_WIDTH,
            config::DEFAULT_DUNGEON_HEIGHT,
        );
        levels.insert(0, initial_level);

        Self {
            levels,
            current_level_id: 0,
            max_depth: 0,
            seed,
            metadata: HashMap::new(),
        }
    }

    /// Gets a reference to the current level.
    pub fn current_level(&self) -> Option<&Level> {
        self.levels.get(&self.current_level_id)
    }

    /// Gets a mutable reference to the current level.
    pub fn current_level_mut(&mut self) -> Option<&mut Level> {
        self.levels.get_mut(&self.current_level_id)
    }

    /// Gets a reference to a specific level by ID.
    pub fn get_level(&self, level_id: u32) -> Option<&Level> {
        self.levels.get(&level_id)
    }

    /// Gets a mutable reference to a specific level by ID.
    pub fn get_level_mut(&mut self, level_id: u32) -> Option<&mut Level> {
        self.levels.get_mut(&level_id)
    }

    /// Adds a new level to the world.
    pub fn add_level(&mut self, level: Level) {
        let level_id = level.id;
        self.levels.insert(level_id, level);
    }

    /// Changes the current level.
    ///
    /// Returns an error if the target level doesn't exist.
    pub fn change_level(&mut self, level_id: u32) -> ThatchResult<()> {
        if !self.levels.contains_key(&level_id) {
            return Err(ThatchError::InvalidState(format!(
                "Level {} does not exist",
                level_id
            )));
        }

        self.current_level_id = level_id;
        if level_id > self.max_depth {
            self.max_depth = level_id;
        }

        Ok(())
    }

    /// Gets the total number of levels in the world.
    pub fn level_count(&self) -> usize {
        self.levels.len()
    }

    /// Sets world-wide metadata (useful for LLDM integration).
    pub fn set_metadata(&mut self, key: String, value: String) {
        self.metadata.insert(key, value);
    }

    /// Gets world-wide metadata value by key.
    pub fn get_metadata(&self, key: &str) -> Option<&String> {
        self.metadata.get(key)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_tile_type_passability() {
        assert!(TileType::Floor.is_passable());
        assert!(!TileType::Wall.is_passable());
        assert!(TileType::Door { is_open: true }.is_passable());
        assert!(!TileType::Door { is_open: false }.is_passable());
    }

    #[test]
    fn test_tile_type_transparency() {
        assert!(TileType::Floor.is_transparent());
        assert!(!TileType::Wall.is_transparent());
        assert!(TileType::Door { is_open: true }.is_transparent());
        assert!(!TileType::Door { is_open: false }.is_transparent());
    }

    #[test]
    fn test_tile_creation() {
        let tile = Tile::new(TileType::Floor);
        assert_eq!(tile.tile_type, TileType::Floor);
        assert!(!tile.explored);
        assert!(!tile.visible);
    }

    #[test]
    fn test_tile_visibility() {
        let mut tile = Tile::floor();
        assert!(!tile.explored);
        assert!(!tile.visible);

        tile.set_visible(true);
        assert!(tile.explored);
        assert!(tile.visible);

        tile.set_visible(false);
        assert!(tile.explored); // Remains explored
        assert!(!tile.visible);
    }

    #[test]
    fn test_level_creation() {
        let level = Level::new(1, 10, 5);
        assert_eq!(level.id, 1);
        assert_eq!(level.width, 10);
        assert_eq!(level.height, 5);
        assert_eq!(level.tiles.len(), 5);
        assert_eq!(level.tiles[0].len(), 10);
    }

    #[test]
    fn test_level_bounds_checking() {
        let level = Level::new(0, 10, 10);
        assert!(level.is_valid_position(Position::new(0, 0)));
        assert!(level.is_valid_position(Position::new(9, 9)));
        assert!(!level.is_valid_position(Position::new(10, 5)));
        assert!(!level.is_valid_position(Position::new(-1, 5)));
    }

    #[test]
    fn test_level_tile_access() {
        let mut level = Level::new(0, 10, 10);
        let pos = Position::new(5, 5);

        // Initial tile should be a wall
        assert_eq!(level.get_tile(pos).unwrap().tile_type, TileType::Wall);

        // Set to floor
        level.set_tile(pos, Tile::floor()).unwrap();
        assert_eq!(level.get_tile(pos).unwrap().tile_type, TileType::Floor);

        // Out of bounds should fail
        let invalid_pos = Position::new(20, 20);
        assert!(level.set_tile(invalid_pos, Tile::floor()).is_err());
    }

    #[test]
    fn test_level_entity_management() {
        let mut level = Level::new(0, 10, 10);
        let entity_id = crate::new_entity_id();

        assert_eq!(level.get_entities().len(), 0);

        level.add_entity(entity_id);
        assert_eq!(level.get_entities().len(), 1);
        assert!(level.get_entities().contains(&entity_id));

        level.remove_entity(&entity_id);
        assert_eq!(level.get_entities().len(), 0);
    }

    #[test]
    fn test_world_creation() {
        let world = World::new(12345);
        assert_eq!(world.current_level_id, 0);
        assert_eq!(world.max_depth, 0);
        assert_eq!(world.seed, 12345);
        assert!(world.levels.contains_key(&0));
    }

    #[test]
    fn test_world_level_management() {
        let mut world = World::new(12345);
        let new_level = Level::new(1, 20, 15);

        world.add_level(new_level);
        assert!(world.levels.contains_key(&1));
        assert_eq!(world.level_count(), 2);

        // Change to new level
        world.change_level(1).unwrap();
        assert_eq!(world.current_level_id, 1);
        assert_eq!(world.max_depth, 1);

        // Invalid level should fail
        assert!(world.change_level(99).is_err());
    }
}
